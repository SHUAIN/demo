<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        let one = {
            name: 'one',
            sayhi(...rest) {
                console.log(rest);
                console.log(`这是${this.name}的函数,这是传递进来的参数：${rest[0]},${rest[1]}`);
            }
        };
        // 普通调用
        one.sayhi('参数一', '参数二');
        let two = {
            name: 'two'
        };
        console.warn('原版使用示范');
        /*使用示范*/
        // 通过bind改变one调用sayhi时， 改变sayhi内部this指向
        one.sayhi.bind(two, '参数1', '参数2')();
        // 通过call改变one调用sayhi时，改变sayhi内部this指向
        one.sayhi.call(two, '参数a', '参数b');
        // 通过apply改变one调用sayhi时，改变sayhi内部this指向
        one.sayhi.apply(two, ['参数a', '参数b']);
        /*手撕代码*/
        // call实现
        Function.prototype.mycall = function (...rest) {
            if (typeof this === 'function') {
                // 获取要绑定的对象
                var obj = rest.splice(0, 1)[0];
                // 给该函数绑定当前调用的函数
                obj[this.name] = this;
                // 将要传递参数再一次传入进去
                obj[this.name](...rest);
                // 删除该方法
                delete obj[this.name];
            } else {
                console.log('该函数只可以被函数调用');
            }
            // 这里要返回目标对象象
            // return  obj[this.name];
        };
        // bind实现
        Function.prototype.mybind = function (...rest) {
            if (typeof this === 'function') {
                // 获取要绑定的对象
                var obj = rest.splice(0, 1)[0];
                var fname = this.name;
                // 给该函数绑定当前调用的函数
                obj[fname] = this;
            } else {
                console.log('该函数只可以被函数调用');
            }
            return function () {
                // 将要传递参数再一次传入进去
                obj[fname](...rest);
                // 删除该方法
                delete obj[fname];
            }
        };
        // apply的实现
        Function.prototype.myapply = function (...rest) {
            if (typeof this === 'function') {
                // 获取要绑定的对象
                var obj = rest.splice(0, 1)[0];
                // 给该函数绑定当前调用的函数
                obj[this.name] = this;
                // 将要传递参数再一次传入进去
                if (rest[0] instanceof Array) {
                    obj[this.name](...rest[0]);

                } else {
                    obj[this.name](rest[0]);
                }
                // 删除该方法
                delete obj.sayhi;
            } else {
                console.log('该函数只可以被函数调用');
            }
            return obj[this.name];
        };
        console.warn('实现测试');
        let test=one.sayhi.mycall(two, 'test1', 'test2');
        one.sayhi.mybind(two, 'testa', 'testb')();
        one.sayhi.myapply(two, 'testA', 'testB');
        function Person(name) {
            this.name = name;
            this.sayhi = function () {
                console.log(`${this.name}向您问好`);
            }
        }

        function Man(name) {
            Person.mycall(this, name);
        }
        let shuaxin = new Man('刷新');
        shuaxin.sayhi();
        console.log(shuaxin);
    </script>
</body>

</html>