<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <h1>大o表示法</h1>
    <ol>
        <li>
            算法的效率和数据量的大小有关
        </li>
        <li>
            大o表示法就是用来描述算法的速度如何随着数据量大小而变化的一种计量方式
        </li>
    </ol>
    <h1>常见表示效率比较</h1>
    <p>
        O(1)>O(log(n))>O(n)>O(nlog(n))>O(n的平方)>O(2的n次方)
    </p>
    <h1>大o表示法的推导</h1>
    <ol>
        <li>用常量1取代运行时间中所有加法常量</li>
        <li>在修改后的运行函数中，只保留最高阶</li>
        <li>如果最高存在且不为1，则除去与这个项相乘的常数</li>
    </ol>
    <h1>常见排序算法</h1>
    <ol>
        <li>
            举例：
            <br>
            冒泡/选择/插入/归并/计数/(counting sort)/基数(radix sort)/希尔/堆/桶//快速
        </li>
        <li>
            简单排序：冒泡、选择、插入
        </li>
        <li>
            高级排序：希尔、快速(着重掌握)
        </li>
    </ol>
    <h1>具体实现</h1>
    <ul>
        <li>
            冒泡排序
            <ol>
                <li>双层循环实现，外层循环控制比较结束的位置</li>
                <li>内层循环控制2个比较的值</li>
                <li>冒泡排序需要比较(n-1)+(n-2)+...+1=n(n-1)/2=n的2次方/2-n/2</li>
                <li>换算成大o表示法：O(n的平方)</li>
                <li>交换次数：n*(n-1)/4,即O(n的2次方)</li>
            </ol>
        </li>
        <li>
            选择排序
            <ol>
                <li>选取每一个元素依次和后面的元素进行比较</li>
                <li>如果大于后面的元素，交换位置</li>
                <li>比较次数和冒泡一样</li>
                <li>交换次数为N-1次 即 O(n) ，所以效率高于冒泡</li>
            </ol>
        </li>
        <li>
            插入排序
            <ol>
                <li>简单排序中效率最高的，是其他高级排序的基础</li>
                <li>局部有序：一个队列中被标记的某个元素之前的元素都是有序的，这一部分称为局部有序</li>
                <li>思路：从索引是1的元素开始依次和前一个元素比较，直到找到比他小的位置停止，交换位置；</li>
            </ol>
        </li>
        <li>
            希尔排序
            <ol>
                <li>插入排序的改进，使其效率更高</li>
                <li>希尔排序主要优化了插入排序的最右端出现最小的数据要往最左边插入时，中间移动元素过多的一个效率问题</li>
                <li>思路：先让间隔为5的两个数在一组进行排序；之后再让间隔为3的两个数一组进行排序；最后在进行插入排序</li>
                <li>插入排序就是让间隔为1的两个数进行排序</li>
                <li>间隔的选择根据数据的情况来看
                    <br>
                    平均：一般初始间隔为N/2，每次减半
                    <br>
                    hibbard增量算法计算：2^k-1 k为第几次分组
                </li>

            </ol>
        </li>
        <li>
            快速排序
            <ol>
                <li>大多数情况下，快速排序效率最高</li>
                <li>原理：在一组数中，随机找到一个数，然后把比他小的放在左边，比他大的放在左边；然后对两边的分组重复这个操作</li>
                <li>每次找的这个数称为枢纽</li>
                <li>使用递归实现</li>
                <li>如何找枢纽：取头，中，尾三个数，在这中间取比较中间的数字</li>
            </ol>
        </li>
    </ul>
    <script>
        function ArrayList() {
            this.items = [];
            // 插入元素
            ArrayList.prototype.insert = function (item) {
                this.items.push(item);
            };
            ArrayList.prototype.toString = function () {
                return this.items.join('-');
            };
            // 用到的工具函数
            ArrayList.prototype.swap = function (a, b) {
                if (this.items[a] > this.items[b]) {
                    let tmp = this.items[a];
                    this.items[a] = this.items[b];
                    this.items[b] = tmp;
                }

            }

            /*排序算法*/
            // 1.冒泡算法
            ArrayList.prototype.bubblesort = function () {
                console.time('冒泡排序');
                let length = this.items.length;
                // j来控制比较到的位置
                for (let j = length - 1; j > 0; j--) {
                    // i控制每次比较的值
                    for (let i = 0; i < j; i++) {
                        this.swap(i, i + 1);
                    }
                }
                console.timeEnd('冒泡排序');
            };
            // 2.选择排序
            ArrayList.prototype.selectionsort = function () {
                console.time('选择排序');
                let length = this.items.length;
                for (let i = 0; i < length - 1; i++) {
                    for (let j = i + 1; j < length; j++) {
                        this.swap(i, j);
                    }
                }
                console.timeEnd('选择排序');
            };
            // 3.插入排序
            ArrayList.prototype.insertingsort = function () {
                console.time('插入排序');
                let length = this.items.length;
                // 从索引为1的元素开始
                for (let i = 1; i < length; i++) {
                    let j = i;
                    let tmp = this.items[i];
                    // 让当前元素和之前的每个元素进行比较
                    while (this.items[j - 1] > tmp && j > 0) {
                        this.items[j] = this.items[j - 1];
                        j--;
                    }
                    // 如果找到比他小的 交换位置
                    this.items[j] = tmp;
                }
                console.timeEnd('插入排序');
            }
            // 4.希尔排序
            ArrayList.prototype.shellsort = function () {
                console.time('希尔排序2');
                let length = this.items.length;
                let gap = Math.floor(length / 2);
                while (gap >= 1) {
                    for (let i = gap; i < length; i++) {
                        let tmp = this.items[i];
                        let j = i;
                        while (this.items[j - gap] > tmp && j > gap - 1) {
                            this.items[j] = this.items[j - gap];
                            j -= gap;
                        }
                        this.items[j] = tmp;
                    }
                    gap = Math.floor(gap / 2);

                };
                console.timeEnd('希尔排序2');
            }
            // 5.快速排序
            // 5.1选择枢纽
            ArrayList.prototype.media = function (left, right) {
                // 1.取中间值
                let center = parseInt((left + right) / 2);
                // 2.判断大小 并交换位置 
                if (this.items[left] > this.items[center]) {
                    if (this.items[left] > this.items[right]) {
                        this.swap(left, right);
                    } else {
                        this.swap(left, center);
                    }
                } else {
                    if (this.items[center] > this.items[right]) {
                        this.swap(center, right);
                    }
                }
                // 3.将center转到right-1的位置
                // this.swap(center, right - 1);
                // 返回值
                return this.items[right - 1];
            }
            // 5.2 递归
            ArrayList.prototype.quick = function (left, right) {
                if (left >= right) {
                    return;
                }
                // 取枢纽的坐标
                let pivot = this.media(left, right);
                // 控制循环
                let i = left,
                    j = right;
                while (true) {
                    // 确保枢纽左边都是比他小的
                    while (this.items[i] < pivot) {
                        i++;
                    }
                    // 确保枢纽左边都是比他大的
                    while (this.items[j] > pivot) {
                        j--;
                    }
                    // 这里进行两边的对比交换
                    if (i < j) {
                        this.swap(i, j);
                        i++;
                        j--;
                    } else {
                        break;
                    }
                }
                // 找到枢纽位置
                this.swap(i, right - 1);
                this.quick(left, i - 1);
                this.quick(i + 1, right);
            }
            // 5.3 对外提供的快速排序
            ArrayList.prototype.quicksort = function () {
                console.time('快速排序');
                this.quick(0, this.items.length - 1);
                console.timeEnd('快速排序');
            }
        }
        // 测试代码
        let a = new ArrayList();
        // 随机插入数 进行排序
        for (let i = 0; i < 20; i++) {
            a.insert(1 + parseInt(Math.random() * 100));
        }
        console.log(a.toString());
        // a.bubblesort();
        // a.selectionsort();
        // a.insertingsort();
        // a.shellsort();
        a.quicksort();
        console.log(a.toString());
    </script>
</body>

</html>